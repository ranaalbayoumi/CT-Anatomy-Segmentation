# -*- coding: utf-8 -*-
"""team 11 m(1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rDu-SFb3dculZu25kL617RucZWqAbpUE
"""

# Cell 1: Install dependencies, download/unzip the dataset, and import libraries
!pip install --quiet gdown nibabel numpy scipy scikit-image matplotlib ipywidgets pyvista[all] totalsegmentator medpy itk

# Enable widgets extension (harmless if already enabled)
!jupyter nbextension enable --py widgetsnbextension || true

print("✅ Installed libraries (may have re-used cached packages).")

# Download and unzip the dataset
!gdown --id 1l6ViBkrONX5KAdziNfeB7G3AS98pb5WV
!unzip -o CT_subset_big.zip

print("✅ Downloaded and unzipped dataset.")

# Import necessary libraries
import nibabel as nib
import matplotlib.pyplot as plt
from ipywidgets import interactive, IntSlider
from IPython.display import display, clear_output, HTML
import shutil
from totalsegmentator.python_api import totalsegmentator
import os
import numpy as np
import pyvista as pv
import ipywidgets as widgets
from tqdm import tqdm
import pandas as pd
from medpy.metric.binary import hd95
from matplotlib.colors import ListedColormap
from matplotlib import cm

import nibabel as nib
import matplotlib.pyplot as plt
from ipywidgets import interactive, IntSlider
from IPython.display import display

def show_nii_slice(nii_path, slice_idx):
    img = nib.load(nii_path)
    data = img.get_fdata()
    plt.imshow(data[:, :, slice_idx], cmap='gray')
    plt.title(f'Slice {slice_idx}')
    plt.axis('off')
    plt.show()

nii_file_path = '/content/s0015/ct.nii.gz'
img = nib.load(nii_file_path)
data = img.get_fdata()
max_slices = data.shape[2] - 1

interactive_plot = interactive(
    show_nii_slice,
    nii_path=nii_file_path,
    slice_idx=IntSlider(min=0, max=max_slices, step=1, description='Slice:')
)
display(interactive_plot)

# Cell 3: Run TotalSegmentator to generate segmentation masks

# Input CT/MRI scan
input_file = '/content/s0015/ct.nii.gz'

# Define output directory for the "total" task
output_dir_total = "segmentations_total_out"

# Remove existing output directory if it exists
if os.path.exists(output_dir_total):
    shutil.rmtree(output_dir_total)
    print(f"Removed directory: {output_dir_total}")
else:
    print(f"Directory not found: {output_dir_total}")

# Create output directory
os.makedirs(output_dir_total, exist_ok=True)

# Run TotalSegmentator for the "total" task (all organs/structures)
print(f"Running TotalSegmentator for task: total")
totalsegmentator(
    input=input_file,
    output=output_dir_total,
    ml=False,               # Save a single multi-label file (segmentations.nii.gz)
    task="total",           # Main task (all structures)
    fast=False,             # If True -> faster but less accurate
    preview=False,          # If True -> quick preview segmentation
    output_type="niftigz"   # Force compressed .nii.gz output
)
print(f"Segmentation done for task 'total'! Check: {output_dir_total}")

# Optional: Filter out empty NIfTI files from the output directory
def filter_empty_files(output_dir):
    for root, dirs, files in os.walk(output_dir):
        for file in files:
            if file.endswith('.nii.gz'):
                file_path = os.path.join(root, file)
                try:
                    img = nib.load(file_path)
                    data = img.get_fdata()
                    if np.sum(data) == 0:
                        print(f"Removing empty file: {file_path}")
                        os.remove(file_path)
                except Exception as e:
                    print(f"Error processing file {file_path}: {e}")

print("\nFiltering empty files from output_dir_total...")
filter_empty_files(output_dir_total)

# Cell 4: 3D visualization of the segmentations

# Path to segmentations
segmentations_dir_total = "/content/segmentations_total_out"

# --- Organ group definitions ---
# Check which segmented files exist for ribs and update the list
rib_files_left = [f"rib_left_{i}.nii.gz" for i in range(1, 13)]
rib_files_right = [f"rib_right_{i}.nii.gz" for i in range(1, 13)]
all_rib_files = rib_files_left + rib_files_right

available_rib_files_left = [f for f in rib_files_left if os.path.exists(os.path.join(segmentations_dir_total, f))]
available_rib_files_right = [f for f in rib_files_right if os.path.exists(os.path.join(segmentations_dir_total, f))]
available_all_rib_files = available_rib_files_left + available_rib_files_right

# Added more organ groups
organ_groups = {
    "Lungs": [
        "lung_upper_lobe_left.nii.gz",
        "lung_lower_lobe_left.nii.gz",
        "lung_middle_lobe_right.nii.gz",
        "lung_upper_lobe_right.nii.gz",
        "lung_lower_lobe_right.nii.gz",
    ],
    "Vertebrae": [
        "vertebrae_L1.nii.gz", "vertebrae_L2.nii.gz", "vertebrae_L3.nii.gz",
        "vertebrae_L4.nii.gz", "vertebrae_L5.nii.gz", "vertebrae_S1.nii.gz",
        "vertebrae_T11.nii.gz", "vertebrae_T12.nii.gz"
    ],
    "Ribs (Left)": available_rib_files_left,
    "Ribs (Right)": available_rib_files_right,
    "Ribs (All)": available_all_rib_files,
    "Abdominal Organs": [
        "liver.nii.gz", "spleen.nii.gz", "kidney_left.nii.gz", "kidney_right.nii.gz",
        "gallbladder.nii.gz", "pancreas.nii.gz", "adrenal_gland_left.nii.gz",
        "adrenal_gland_right.nii.gz", "stomach.nii.gz", "small_bowel.nii.gz",
        "duodenum.nii.gz", "colon.nii.gz", "urinary_bladder.nii.gz", "prostate.nii.gz" # Added prostate
    ],
    "Heart and Veins": [
        "heart.nii.gz", "aorta.nii.gz", "inferior_vena_cava.nii.gz",
        "superior_vena_cava.nii.gz", "pulmonary_vein.nii.gz",
        "portal_vein_and_splenic_vein.nii.gz", "brachiocephalic_trunk.nii.gz",
        "brachiocephalic_vein_left.nii.gz", "brachiocephalic_vein_right.nii.gz",
        "common_carotid_artery_left.nii.gz", "common_carotid_artery_right.nii.gz",
        "subclavian_artery_left.nii.gz", "subclavian_artery_right.nii.gz",
        "iliac_artery_left.nii.gz", "iliac_artery_right.nii.gz",
        "iliac_vena_left.nii.gz", "iliac_vena_right.nii.gz"
    ],
    "Muscles": [
        "psoas_major_left.nii.gz", "psoas_major_right.nii.gz", # Added psoas_major
        "iliopsoas_left.nii.gz", "iliopsoas_right.nii.gz",
        "gluteus_maximus_left.nii.gz", "gluteus_maximus_right.nii.gz",
        "gluteus_medius_left.nii.gz", "gluteus_medius_right.nii.gz",
        "gluteus_minimus_left.nii.gz", "gluteus_minimus_right.nii.gz",
        "autochthon_left.nii.gz", "autochthon_right.nii.gz"
    ],
    "Bones": [
        "skull.nii.gz", "clavicula_left.nii.gz", "clavicula_right.nii.gz",
        "scapula_left.nii.gz", "scapula_right.nii.gz", "humerus_left.nii.gz",
        "humerus_right.nii.gz", "femur_left.nii.gz", "femur_right.nii.gz",
        "hip_left.nii.gz", "hip_right.nii.gz", "sacrum.nii.gz", "sternum.nii.gz",
        "costal_cartilages.nii.gz" # Added costal_cartilages
    ],
    "Others": [
        "spinal_cord.nii.gz", "esophagus.nii.gz", "trachea.nii.gz",
        "thyroid_gland.nii.gz", "atrial_appendage_left.nii.gz",
        "kidney_cyst_left.nii.gz", "kidney_cyst_right.nii.gz"
    ]
}

# --- UI widgets ---
organ_dropdown = widgets.Dropdown(
    options=list(organ_groups.keys()),
    description="Organ:",
    value="Lungs",
    style={'description_width': 'initial'}, # Added styling
    layout=widgets.Layout(width="auto") # Adjusted width
)

parts_select = widgets.SelectMultiple(
    options=[],
    description="Parts:",
    disabled=False,
    layout=widgets.Layout(width="95%", height="150px") # Adjusted width and height
)

controls_area = widgets.Output(layout=widgets.Layout(border='1px solid #aaddff', padding='10px', margin='10px 0')) # Added styling
plot_area = widgets.Output()

# Global store
current_segment_widgets = []
plotter = pv.Plotter(notebook=True)


# --- Build widgets for each selected part ---
def make_widgets(segmentation_files):
    widgets_list = []
    initial_colors = ["#FF6347", "#4682B4", "#32CD32", "#FFD700", "#9370DB", "#00CED1", "#FF8C00", "#FF69B4"] # More visually appealing colors

    for i, seg_file in enumerate(segmentation_files):
        color_picker = widgets.ColorPicker(
            concise=False, # Changed to concise=False
            description=f"{seg_file.replace('.nii.gz', '')} Color:", # Shortened description
            value=initial_colors[i % len(initial_colors)],
            layout=widgets.Layout(width="150px") # Fixed width
        )
        opacity_slider = widgets.FloatSlider(
            value=0.6, min=0, max=1, step=0.01,
            description="Opacity:", continuous_update=False,
            layout=widgets.Layout(width="250px") # Increased width
        )
        visibility_checkbox = widgets.Checkbox(value=True, description="Visible")

        widgets_list.append({
            "file": seg_file,
            "color_picker": color_picker,
            "opacity_slider": opacity_slider,
            "visibility_checkbox": visibility_checkbox
        })

    return widgets_list


# --- Refresh PyVista plot based on current widget states ---
def refresh_plot(change=None):
    with plot_area:
        clear_output(wait=True)
        plotter.clear_actors()

        for seg_widget in current_segment_widgets:
            seg_file = seg_widget["file"]
            seg_path = os.path.join(segmentations_dir_total, seg_file)

            if not os.path.exists(seg_path):
                print(f"Missing file: {seg_file}")
                continue

            seg_img = nib.load(seg_path)
            seg_data = seg_img.get_fdata()

            if np.sum(seg_data) > 0:
                seg_grid = pv.wrap(seg_data)
                mesh = seg_grid.contour(isosurfaces=[0.5])

                if mesh.n_points > 0:
                    smoothed_mesh = mesh.smooth(n_iter=50, relaxation_factor=0.1)
                    color_val = seg_widget["color_picker"].value
                    opacity = seg_widget["opacity_slider"].value
                    visible = seg_widget["visibility_checkbox"].value
                    if visible:
                        plotter.add_mesh(smoothed_mesh, color=color_val, opacity=opacity, name=seg_file)

        plotter.camera_position = "iso"
        html_output = plotter.show(jupyter_backend="html")
        display(HTML(html_output))


# --- Update available parts when organ changes ---
def update_parts(change=None):
    selected_organ = organ_dropdown.value
    parts_select.options = ["[All]"] + organ_groups[selected_organ]
    parts_select.value = ("[All]",)


# --- Update when parts selection changes ---
def update_plot(change=None):
    global current_segment_widgets

    selected_organ = organ_dropdown.value
    selected_parts = parts_select.value

    if "[All]" in selected_parts:
        segmentation_files = organ_groups[selected_organ]
    else:
        segmentation_files = list(selected_parts)

    # Filter out missing files before making widgets
    existing_segmentation_files = [f for f in segmentation_files if os.path.exists(os.path.join(segmentations_dir_total, f))]


    # Build widgets only once when selection changes
    current_segment_widgets = make_widgets(existing_segmentation_files)

    with controls_area:
        clear_output(wait=True)
        # Arranged widgets in a more compact way
        widget_boxes = [
            widgets.HBox([seg_widget["color_picker"], seg_widget["opacity_slider"], seg_widget["visibility_checkbox"]])
            for seg_widget in current_segment_widgets
        ]
        display(widgets.VBox([widgets.Label("Adjust Segmentation Appearance:")] + widget_boxes, layout=widgets.Layout(border='1px solid #ccffcc', padding='10px', margin='10px 0'))) # Added styling


        # Hook widget changes to refresh_plot (not rebuild!)
        for seg_widget in current_segment_widgets:
            seg_widget["color_picker"].observe(refresh_plot, names="value")
            seg_widget["opacity_slider"].observe(refresh_plot, names="value")
            seg_widget["visibility_checkbox"].observe(refresh_plot, names="value")

    refresh_plot()


# Hook changes
organ_dropdown.observe(update_parts, names="value")
parts_select.observe(update_plot, names="value")

# Display UI
# Reverted to a more vertical layout with styled containers
main_layout = widgets.VBox([
    widgets.Label("3D Segmentation Visualization", style={'font_weight': 'bold', 'font_size': '16px'}), # Added title
    widgets.HBox([organ_dropdown, parts_select]),
    controls_area,
    plot_area
], layout=widgets.Layout(border='2px solid #cccccc', padding='20px', background='#f0f0f0')) # Added overall container styling
display(main_layout)

# Initial state
update_parts()
update_plot()

# Cell 5: Evaluation and metrics

# ----------------- CONFIG -----------------
raw_file = "/content/s0015/ct.nii.gz"                 # raw CT
gt_dir   = "/content/s0015/segmentations"            # ground-truth masks
pred_dir = "/content/segmentations_total_out"        # predicted masks

# The organ groups we visualize (display names -> their component filenames prefix)
organs_display = {
    "Ribs": [f"rib_left_{i}" for i in range(1, 13)] + [f"rib_right_{i}" for i in range(1, 13)],
    "Lungs": ["lung_upper_lobe_left", "lung_upper_lobe_right",
              "lung_middle_lobe_right", "lung_lower_lobe_left",
              "lung_lower_lobe_right"],
    "Vertebrae": ["vertebrae_L1", "vertebrae_L2", "vertebrae_L3",
                  "vertebrae_L4", "vertebrae_L5", "vertebrae_S1",
                  "vertebrae_T8", "vertebrae_T9", "vertebrae_T10",
                  "vertebrae_T11", "vertebrae_T12"]
}
# Mapping from display-name -> organ-key used in CSV (adjust if your CSV uses other names)
csv_organ_key = {
    "Ribs": "ribs",
    "Lungs": "lungs",
    "Vertebrae": "vertebrae"
}
# Candidate CSV filenames/paths to try
csv_candidates = [
    "evaluation_results_filtered.csv",
    "evaluation_results.csv",
    "/content/evaluation_results_filtered.csv",
    "/content/evaluation_results.csv",
    "/content/s0015/evaluation_results_filtered.csv",
    "/content/s0015/evaluation_results.csv"
]
# -------------------------------------------

# Load raw image
if not os.path.exists(raw_file):
    raise FileNotFoundError(f"Raw file not found: {raw_file}")
raw_img = nib.load(raw_file)
raw_data = raw_img.get_fdata()
nx, ny, nz = raw_data.shape

# Try to find CSV
csv_path = None
for p in csv_candidates:
    if os.path.exists(p):
        csv_path = p
        break

if csv_path:
    print("Loaded metrics CSV:", csv_path)
    df_csv = pd.read_csv(csv_path)
    # ensure lowercase columns
    df_csv.columns = [c.lower() for c in df_csv.columns]
    if 'organ' not in df_csv.columns:
        print("Warning: CSV does not contain 'organ' column — falling back to compute metrics.")
        df_group = None
    else:
        # group by organ and average
        # keep dice,iou,hd95 columns if present
        metric_cols = [c for c in ['dice','iou','hd95'] if c in df_csv.columns]
        if len(metric_cols) == 0:
            df_group = None
        else:
            df_group = df_csv.groupby('organ')[metric_cols].mean()
            print("Per-organ averages from CSV:")
            display(df_group)
else:
    print("No CSV found in candidates. Will compute metrics from masks if needed.")
    df_group = None

# Utility metrics fallback (if CSV missing metric)
def dice_bin(gt, pred):
    gt_b = (gt > 0)
    pr_b = (pred > 0)
    if gt_b.sum() == 0 and pr_b.sum() == 0:
        return 1.0
    inter = np.logical_and(gt_b, pr_b).sum()
    return 2.0 * inter / (gt_b.sum() + pr_b.sum() + 1e-12)

def iou_bin(gt, pred):
    gt_b = (gt > 0)
    pr_b = (pred > 0)
    if gt_b.sum() == 0 and pr_b.sum() == 0:
        return 1.0
    inter = np.logical_and(gt_b, pr_b).sum()
    union = np.logical_or(gt_b, pr_b).sum()
    return inter / (union + 1e-12)

def hd95_bin(gt, pred):
    try:
        from medpy.metric.binary import hd95 as medpy_hd95
        MEDPY_AVAILABLE = True
    except Exception:
        MEDPY_AVAILABLE = False

    if not MEDPY_AVAILABLE:
        return np.nan
    gt_b = (gt > 0).astype(np.uint8)
    pr_b = (pred > 0).astype(np.uint8)
    try:
        return float(medpy_hd95(pr_b, gt_b)) # Ensure float return
    except Exception:
        return np.nan

# Precompute labeled volumes per organ and prepare colormaps + metrics (use CSV averages if available)
base_cmap = plt.colormaps.get_cmap("tab20")

organ_data = {}
for display_name, parts in organs_display.items():
    n_parts = len(parts)
    gt_lab = np.zeros((nx, ny, nz), dtype=np.int16)
    pr_lab = np.zeros((nx, ny, nz), dtype=np.int16)

    # load parts into labeled volumes (label 1..n_parts)
    for idx, part_prefix in enumerate(parts, start=1):
        fname = part_prefix + ".nii.gz"
        gt_path = os.path.join(gt_dir, fname)
        pr_path = os.path.join(pred_dir, fname)
        if os.path.exists(gt_path):
            arr = nib.load(gt_path).get_fdata() > 0
            gt_lab[arr & (gt_lab == 0)] = idx
        if os.path.exists(pr_path):
            arrp = nib.load(pr_path).get_fdata() > 0
            pr_lab[arrp & (pr_lab == 0)] = idx

    # prepare ListedColormap: background transparent + per-part rgba
    rgba_colors = [base_cmap(i % base_cmap.N) for i in range(n_parts)]
    gt_colors = [(0,0,0,0.0)] + [(r,g,b,0.75) for (r,g,b,_) in rgba_colors]
    pr_colors = [(0,0,0,0.0)] + [(r,g,b,0.40) for (r,g,b,_) in rgba_colors]
    gt_cmap = ListedColormap(gt_colors)
    pr_cmap = ListedColormap(pr_colors)

    # metrics: prefer CSV averages if available
    csv_key = csv_organ_key.get(display_name, display_name.lower())
    metrics = {"dice": np.nan, "iou": np.nan, "hd95": np.nan}
    if df_group is not None and csv_key in df_group.index:
        row = df_group.loc[csv_key]
        for col in ['dice','iou','hd95']:
            if col in row.index:
                metrics[col] = float(row[col])
    else:
        # fallback: compute from combined binary masks
        gt_combined = (gt_lab > 0).astype(np.uint8)
        pr_combined = (pr_lab > 0).astype(np.uint8)
        metrics['dice'] = dice_bin(gt_combined, pr_combined)
        metrics['iou'] = iou_bin(gt_combined, pr_combined)
        metrics['hd95'] = hd95_bin(gt_combined, pr_combined)


    organ_data[display_name] = {
        "parts": parts,
        "n_parts": n_parts,
        "gt_lab": gt_lab,
        "pr_lab": pr_lab,
        "gt_cmap": gt_cmap,
        "pr_cmap": pr_cmap,
        "metrics": metrics
    }

# Build interactive UI: one slider + output per organ (images draw inside the output)
ui_widgets = []
for organ, info in organ_data.items():
    max_slice = nz - 1
    slider = widgets.IntSlider(min=0, max=max_slice, step=1, value=max_slice//2,
                               description=f"{organ} slice", layout=widgets.Layout(width="80%", margin="0 0 10px 0"))
    out = widgets.Output(layout=widgets.Layout(border="1px solid #ddd", margin="0 0 20px 0"))

    def make_handler(organ, slider, out):
        info = organ_data[organ]
        def handler(change):
            slice_idx = change['new'] if isinstance(change, dict) else slider.value
            with out:
                clear_output(wait=True)
                raw_slice = raw_data[:, :, slice_idx]
                gt_slice = info["gt_lab"][:, :, slice_idx]
                pr_slice = info["pr_lab"][:, :, slice_idx]

                fig, axes = plt.subplots(1, 3, figsize=(15, 5))
                axes[0].imshow(raw_slice.T, cmap="gray", origin="lower")
                axes[0].set_title(f"{organ} — Raw")
                axes[0].axis("off")

                axes[1].imshow(raw_slice.T, cmap="gray", origin="lower")
                axes[1].imshow(gt_slice.T, cmap=info["gt_cmap"], origin="lower", vmin=0, vmax=info["n_parts"])
                axes[1].set_title("Ground Truth (parts)")
                axes[1].axis("off")

                axes[2].imshow(raw_slice.T, cmap="gray", origin="lower")
                axes[2].imshow(pr_slice.T, cmap=info["pr_cmap"], origin="lower", vmin=0, vmax=info["n_parts"])
                axes[2].set_title("Prediction (parts)")
                axes[2].axis("off")

                # metrics text under figure (from CSV averages if available)
                m = info["metrics"]
                met_text = f"Dice: {m['dice']:.4f}    IoU: {m['iou']:.4f}    HD95: {m['hd95'] if (not np.isnan(m['hd95'])) else 'nan'}"
                fig.text(0.5, -0.05, met_text, ha='center', fontsize=11) # Adjusted text position

                display(fig)
                plt.close(fig)
        return handler

    handler = make_handler(organ, slider, out)
    slider.observe(handler, names='value')
    # initial render
    handler({'new': slider.value})
    ui_widgets.append(widgets.VBox([widgets.Label(f"Organ: {organ}"), slider, out])) # Added organ label

# Show them stacked
display(widgets.VBox(ui_widgets, layout=widgets.Layout(border="1px solid #ccc", padding="20px"))) # Added border and padding